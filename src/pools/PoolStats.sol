// SPDX-License-Identifier: BUSL 1.1
pragma solidity =0.8.21;

import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "./PoolUtils.sol";
import "./interfaces/IPoolStats.sol";
import "../interfaces/IExchangeConfig.sol";
import "./interfaces/IPoolsConfig.sol";


// Keeps track of the arbitrage profits generated by pools (for proportional rewards distribution on performUpkeep).
contract PoolStats is IPoolStats
	{
	IExchangeConfig immutable public exchangeConfig;
	IPoolsConfig immutable public poolsConfig;

	// poolID(arbToken2, arbToken3) => arbitrage on whitelisted swaps since the last performUpkeep
	mapping(bytes32=>uint256) private _whitelistedArbitrage;

	// poolID(arbToken2, arbToken3) => arbitrage on unwhitelisted swaps since the last performUpkeep
	mapping(bytes32=>uint256) private _unwhitelistedArbitrage;

	// Used to cache the index of each poolID (to increase accounting speed)
	mapping(bytes32=>uint256) private _poolIndicies;


    constructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig )
    	{
		require( address(_exchangeConfig) != address(0), "_exchangeConfig cannot be address(0)" );
		require( address(_poolsConfig) != address(0), "_poolsConfig cannot be address(0)" );

		exchangeConfig = _exchangeConfig;
		poolsConfig = _poolsConfig;
    	}


	// Keep track of the which pools contributed to a recent arbitrage profit so that they can be rewarded later on performUpkeep.
	function _updateProfitsFromArbitrage( bool isWhitelistedPair, IERC20 arbToken2, IERC20 arbToken3, uint256 arbitrageProfit ) internal
		{
		if ( arbitrageProfit == 0 )
			return;

		bytes32 poolID = PoolUtils._poolIDOnly( arbToken2, arbToken3 );

		if ( isWhitelistedPair )
			_whitelistedArbitrage[poolID] += arbitrageProfit;
		else
			_unwhitelistedArbitrage[poolID] += arbitrageProfit;
		}


	function clearProfitsForPools( bytes32[] memory poolIDs ) public
		{
		require(msg.sender == address(exchangeConfig.upkeep()), "PoolStats.clearProfitsForPools is only callable from the Upkeep contract" );

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			bytes32 poolID = poolIDs[i];

			_whitelistedArbitrage[poolID] = 0;
			_unwhitelistedArbitrage[poolID] = 0;
			}
		}


	function _accumulateProfit( IERC20 tokenA, IERC20 tokenB, uint256 arbitrageProfit, uint256[] memory _profits ) internal view
		{
		}


	// Split up the arbitrage that has been seen since the last performUpkeep call and credit the pools that have contributed towards it.
	function _calculateArbitrageProfits( bytes32[] memory poolIDs, uint256[] memory _calculatedProfits ) public view
		{
		IERC20 wbtc = exchangeConfig.wbtc();
		IERC20 weth = exchangeConfig.weth();

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			bytes32 poolID = poolIDs[i];

			(IERC20 tokenA, IERC20 tokenB) = poolsConfig.underlyingTokenPair(poolID);

			// Split the arbitrage profit between all the pools that contributed to generating it
			if ( poolsConfig.isWhitelisted(poolID) )
				{
				// The generated profit will be divided between three pools
				uint256 arbitrageProfit = _whitelistedArbitrage[poolID] / 3;

				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( weth, tokenA )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenA, tokenB )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenB, weth )] ] += arbitrageProfit;
				}
			else
				{
				// The generated profit will be divided between four pools
				uint256 arbitrageProfit = _whitelistedArbitrage[poolID] / 4;

				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( weth, tokenA )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenA, wbtc )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( wbtc, tokenB )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenB, weth )] ] += arbitrageProfit;
				}
			}
		}


	function profitsForPools( bytes32[] memory poolIDs ) public returns (uint256[] memory _calculatedProfits)
		{
		require(msg.sender == address(exchangeConfig.upkeep()), "PoolStats.profitsForPools is only callable from the Upkeep contract" );

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			if ( _poolIndicies[poolIDs[i]] != i )
				_poolIndicies[poolIDs[i]] = i;
			}

		_calculatedProfits = new uint256[](poolIDs.length);

		_calculateArbitrageProfits( poolIDs, _calculatedProfits );
		}
	}