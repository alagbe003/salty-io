// SPDX-License-Identifier: BUSL 1.1
pragma solidity =0.8.22;

import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "./PoolUtils.sol";
import "./interfaces/IPoolStats.sol";
import "../interfaces/IExchangeConfig.sol";
import "./interfaces/IPoolsConfig.sol";


// Keeps track of the arbitrage profits generated by pools (for proportional rewards distribution on performUpkeep).
contract PoolStats is IPoolStats
	{
	IExchangeConfig immutable public exchangeConfig;
	IPoolsConfig immutable public poolsConfig;

	// poolID(arbToken2, arbToken3) => arbitrage on whitelisted swaps since the last performUpkeep
	mapping(bytes32=>uint256) public _whitelistedArbitrage;

	// poolID(arbToken2, arbToken3) => arbitrage on unwhitelisted swaps since the last performUpkeep
	mapping(bytes32=>uint256) public _unwhitelistedArbitrage;

	// Used to cache the index of each poolID (to increase accounting speed)
	mapping(bytes32=>uint256) public _poolIndicies;


    constructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig )
    	{
		require( address(_exchangeConfig) != address(0), "_exchangeConfig cannot be address(0)" );
		require( address(_poolsConfig) != address(0), "_poolsConfig cannot be address(0)" );

		exchangeConfig = _exchangeConfig;
		poolsConfig = _poolsConfig;
    	}


	// Keep track of the which pools contributed to a recent arbitrage profit so that they can be rewarded later on performUpkeep.
	function _updateProfitsFromArbitrage( bool isWhitelistedPair, IERC20 arbToken2, IERC20 arbToken3, uint256 arbitrageProfit ) internal
		{
		if ( arbitrageProfit == 0 )
			return;

		// arbToken2+arbToken3 represents the exact arbitrage path that was taken
		// For whitelisted user swaps: WETH->arbToken2->arbToken3->WETH
		// For unwhitelisted user swaps: WETH->arbToken2->WBTC->arbToken3->WETH
		bytes32 poolID = PoolUtils._poolIDOnly( arbToken2, arbToken3 );

		if ( isWhitelistedPair )
			_whitelistedArbitrage[poolID] += arbitrageProfit;
		else
			_unwhitelistedArbitrage[poolID] += arbitrageProfit;
		}


	// Called at the end of Upkeep.performUpkeep to reset the arbitrage stats for the pools
	function clearProfitsForPools( bytes32[] memory poolIDs ) public
		{
		require(msg.sender == address(exchangeConfig.upkeep()), "PoolStats.clearProfitsForPools is only callable from the Upkeep contract" );

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			bytes32 poolID = poolIDs[i];

			_whitelistedArbitrage[poolID] = 0;
			_unwhitelistedArbitrage[poolID] = 0;
			}
		}


	// Split up the arbitrage that has been seen since the last Upkeep.performUpkeep call and credit the pools that have contributed towards it.
	// The calculated sums for each pool will then be used to proportionally distribute SALT rewards to each of the pools.
	function _calculateArbitrageProfits( bytes32[] memory poolIDs, uint256[] memory _calculatedProfits ) internal view
		{
		IERC20 wbtc = exchangeConfig.wbtc();
		IERC20 weth = exchangeConfig.weth();

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			bytes32 poolID = poolIDs[i];

			(IERC20 tokenA, IERC20 tokenB) = poolsConfig.underlyingTokenPair(poolID);

			// Split the arbitrage profit between all the pools that contributed to generating the arbitrage
			if ( poolsConfig.isWhitelisted(poolID) )
				{
				// The generated profit will be divided between three pools
				uint256 arbitrageProfit = _whitelistedArbitrage[poolID] / 3;

				// Arbitrage path was WETH->tokenA->tokenB->WETH
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( weth, tokenA )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenA, tokenB )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenB, weth )] ] += arbitrageProfit;
				}
			else
				{
				// The generated profit will be divided between four pools
				uint256 arbitrageProfit = _whitelistedArbitrage[poolID] / 4;

				// Arbitrage path was WETH->tokenA->WBTC->tokenB->WETH
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( weth, tokenA )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenA, wbtc )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( wbtc, tokenB )] ] += arbitrageProfit;
				_calculatedProfits[ _poolIndicies[ PoolUtils._poolIDOnly( tokenB, weth )] ] += arbitrageProfit;
				}
			}
		}


	// Look at the arbitrage that has been generated since the last performUpkeep and determine how much each of the pools contributed to those generated profits.
	// Note that poolIDs must not include any duplicate IDs to work correctly.
	// Only callable by the Upkeep contract.
	function profitsForPools( bytes32[] memory poolIDs ) public returns (uint256[] memory _calculatedProfits)
		{
		require(msg.sender == address(exchangeConfig.upkeep()), "PoolStats.profitsForPools is only callable from the Upkeep contract" );

		for( uint256 i = 0; i < poolIDs.length; i++ )
			{
			if ( _poolIndicies[poolIDs[i]] != i )
				_poolIndicies[poolIDs[i]] = i;
			}

		_calculatedProfits = new uint256[](poolIDs.length);

		_calculateArbitrageProfits( poolIDs, _calculatedProfits );
		}
	}